<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>개발팀 알고리즘 6주차</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    
    
</head>
<body>
1. 2 x n 타일링 lv.3<br>
<script>
    const solution1 = n => {
        let answer = 0;
        const arr = [1,1];
        for (let i=2; i <= n; i++){
            arr[i] = (arr[i-1] + arr[i-2]) % 1000000007; //경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요.
        //[1,1,2,3,5]
        };
        answer = arr[arr.length - 1];
        return answer;
        /*
        피보나치 수(영어: Fibonacci numbers)
        https://shoark7.github.io/programming/algorithm/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-5%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95
        
        let rectWidth = Array(n).fill(0); 예제는 맞았으나 완전히 틀린 풀이
        const process1 = [1,2];
        for(let i in rectWidth){
            for(let j of process1){
                if(rectWidth.reduce((a,c)=>a+c) === n){
                    answer += 1;
                } else {
                    rectWidth[i] += j;  
                }
            }
        }
        
        */
        

    };
    document.write(solution1(4));
</script>
<hr>
2. 멀쩡한 사각형 lv.2<br>
<script>
    const solution2 = (w,h) => {
        const gcd = (w,h) => {    
            const mod = w % h;
            if (mod === 0) {
                return h;
            };
            return gcd(h, mod);
        };
        const gcdVal = gcd(w,h);

        return w*h - (w+h-gcdVal);

        /*
        https://noogoonaa.tistory.com/74 유클리드 호제법
        
        let tmp = []; 반은 통과 반은 실패...
        const process1 = [w,h];
        for(let i of process1){
            for(let j=1; j<i; j++){
                if(i % j === 0){
                    tmp.push(j);
                };
            };
        }; //[1,2,4,1,2,3,4,6]
        const process2 = tmp.filter((v,i)=>{
            return tmp.indexOf(v) !== i;
        }); // [1,2,4]
        const commonFactor = process2[process2.length - 1];
        
        return w*h - (w+h-(commonFactor)); commonFactor는 최대공약수
        
        */

        
    }
    document.write(solution2(8,12));
</script>
</body>
</html>